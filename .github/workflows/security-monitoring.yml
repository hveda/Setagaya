name: Continuous Security Monitoring

on:
  schedule:
    # Run every Monday at 2 AM UTC
    - cron: '0 2 * * 1'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of scan to run'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - dependencies
        - containers
        - secrets

permissions:
  contents: read
  security-events: write
  actions: read
  issues: write

jobs:
  # Comprehensive dependency audit
  dependency-audit:
    name: Dependency Security Audit
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'dependencies' || github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25.1'
        cache: true
        cache-dependency-path: setagaya/go.sum

    - name: Install govulncheck
      run: go install golang.org/x/vuln/cmd/govulncheck@latest

    - name: Install OSV Scanner (Google's vulnerability scanner)
      run: go install github.com/google/osv-scanner/cmd/osv-scanner@latest

    - name: Scan dependencies with OSV Scanner
      run: |
        cd setagaya
        echo "Running OSV Scanner on go.mod..."
        osv-scanner --format json --output osv-results.json go.mod || true

        if [ -f osv-results.json ]; then
          echo "OSV Scanner results:"
          cat osv-results.json | jq '.results[].packages[].vulnerabilities[]?.summary // empty' 2>/dev/null || echo "No vulnerabilities found or JSON parsing failed"
        fi

    - name: Scan dependencies for known vulnerabilities
      run: |
        cd setagaya
        echo "Checking for known vulnerabilities in dependencies..."
        go list -json -m all | jq -r '.Path + "@" + .Version' | sort

    - name: Run govulncheck
      run: |
        cd setagaya
        govulncheck -json ./... > vulns.json || true

    - name: Process vulnerability results
      run: |
        if [ -f setagaya/vulns.json ] && [ -s setagaya/vulns.json ]; then
          echo "Vulnerabilities found:"
          cat setagaya/vulns.json | jq '.message' 2>/dev/null || echo "JSON parsing failed"

          # Check for vulnerability findings and report but don't fail
          vulnerability_count=$(cat setagaya/vulns.json | jq '[.calls[]?, .requires[]?] | length' 2>/dev/null || echo "0")
          if [ "$vulnerability_count" -gt "0" ]; then
            echo "::warning::Found $vulnerability_count vulnerabilities"
            echo "## Dependency Vulnerabilities Detected" >> $GITHUB_STEP_SUMMARY
            echo "- Vulnerability count: $vulnerability_count" >> $GITHUB_STEP_SUMMARY
            echo "This is a monitoring workflow - vulnerabilities detected but workflow continues" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… No vulnerabilities detected in dependency scan"
          fi
        fi

  # Container security monitoring
  container-security-monitoring:
    name: Container Security Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'containers' || github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v5

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Debug build context
      run: |
        echo "Checking build context structure..."
        echo "Repository root contents:"
        ls -la
        echo "Setagaya directory contents:"
        ls -la setagaya/
        echo "UI directory structure:"
        ls -la setagaya/ui/
        echo "UI static directory contents:"
        ls -la setagaya/ui/static/ || echo "Static directory not found"
        echo "UI templates directory contents:"
        ls -la setagaya/ui/templates/ || echo "Templates directory not found"
        echo "Dockerfiles present:"
        ls -la setagaya/Dockerfile*

    - name: Build images for scanning
      run: |
        echo "Building setagaya main image..."
        docker build -f setagaya/Dockerfile -t setagaya-monitor:latest . --build-arg GCP_CREDENTIALS_PATH=""
        echo "Building JMeter engine image..."
        docker build -f setagaya/Dockerfile.engines.jmeter -t setagaya-jmeter-monitor:latest .

    - name: Scan with Trivy
      uses: aquasecurity/trivy-action@0.28.0
      with:
        image-ref: 'setagaya-monitor:latest'
        format: 'json'
        output: 'trivy-results.json'

    - name: Check for HIGH/CRITICAL vulnerabilities
      run: |
        if [ -f trivy-results.json ]; then
          high_count=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' 2>/dev/null || echo "0")
          critical_count=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' 2>/dev/null || echo "0")

          echo "High severity vulnerabilities: $high_count"
          echo "Critical severity vulnerabilities: $critical_count"

          if [ "$critical_count" -gt "0" ] || [ "$high_count" -gt "5" ]; then
            echo "::warning::Found $critical_count critical and $high_count high severity vulnerabilities"
            echo "## Security Alert: High Vulnerability Count" >> $GITHUB_STEP_SUMMARY
            echo "- Critical vulnerabilities: $critical_count" >> $GITHUB_STEP_SUMMARY
            echo "- High vulnerabilities: $high_count" >> $GITHUB_STEP_SUMMARY
            echo "This is a monitoring workflow - vulnerabilities detected but workflow continues" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… Vulnerability levels within acceptable limits"
          fi
        fi

  # Secret monitoring
  secret-monitoring:
    name: Secret Leak Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'secrets' || github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Run comprehensive secret scan
      uses: trufflesecurity/trufflehog@v3.90.6
      with:
        path: ./
        extra_args: --only-verified --json --no-update --fail

    - name: Handle TruffleHog results
      if: always()
      run: |
        echo "TruffleHog scan completed"
        if [ -f trufflehog-results.json ]; then
          echo "Secrets scan results found"
          cat trufflehog-results.json
        else
          echo "No secrets detected or results file not generated"
        fi

    - name: Scan for common patterns
      run: |
        # Additional patterns to check
        echo "Scanning for common secret patterns..."

        exit_code=0

        # Check for potential AWS keys (more specific pattern)
        if grep -r "AKIA[0-9A-Z]\{16\}" . --exclude-dir=.git --exclude-dir=node_modules --exclude="*.md" | grep -v "example\|template\|test"; then
          echo "::error::Potential AWS access key found!"
          exit_code=1
        fi

        # Check for potential private keys (exclude documentation and workflow files)
        if grep -r "BEGIN.*PRIVATE KEY" . --exclude-dir=.git --exclude-dir=node_modules --exclude="*.md" --exclude="*.yml" --exclude="*.yaml" | grep -v "example\|template\|test\|documentation"; then
          echo "::error::Potential private key found!"
          exit_code=1
        fi

        # Check for hardcoded passwords (improved pattern to reduce false positives)
        if grep -ri "password\s*[:=]\s*[\"'][^\"']*[\"']" . --include="*.go" --include="*.yaml" --include="*.json" | \
           grep -v "password_hash\|password_file\|_test\.go\|example\|template\|\.Form\.Get\|systemPassword\|ns\.password\|\.Password" | \
           grep -v "values\.yaml\|test_utils\.go\|init\.go.*test\|''$\|\"\"$\|'root'\|\"test\"\|\"root\"\|'test'" | \
           grep -v "SystemPassword.*test\|Password.*test\|system_password.*''"; then
          echo "::error::Potential hardcoded password found!"
          exit_code=1
        fi

        # Check for potential API keys or tokens
        if grep -ri "api[_-]key\s*[:=]\s*[\"'][^\"']*[\"']" . --include="*.go" --include="*.yaml" --include="*.json" | grep -v "example\|template\|test\|_test.go"; then
          echo "::error::Potential API key found!"
          exit_code=1
        fi

        exit $exit_code

  # License compliance monitoring
  license-compliance:
    name: License Compliance Check
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25.1'
        cache: true
        cache-dependency-path: setagaya/go.sum

    - name: Install go-licenses
      run: go install github.com/google/go-licenses@latest

    - name: Check for license issues
      run: |
        cd setagaya
        go-licenses check ./... --disallowed_types=forbidden,restricted \
          --ignore="github.com/hveda/Setagaya" \
          --ignore="github.com/iandyh/eventsource" || true

    - name: Generate license report
      run: |
        cd setagaya
        go-licenses report ./... \
          --ignore="github.com/hveda/Setagaya" \
          --ignore="github.com/iandyh/eventsource" > ../license-report.txt || true
        echo "License report generated"

    - name: Upload license report
      uses: actions/upload-artifact@v4
      with:
        name: license-report
        path: license-report.txt

  # SBOM generation and monitoring
  sbom-monitoring:
    name: SBOM Generation and Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v5

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        path: ./
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Scan SBOM for vulnerabilities
      uses: anchore/scan-action@v3
      continue-on-error: true
      with:
        sbom: sbom.spdx.json
        output-format: sarif
        output-file: sbom-scan-results.sarif
        severity-cutoff: high
        fail-build: false

    - name: Validate and fix SARIF file
      if: always()
      run: |
        if [ -f sbom-scan-results.sarif ]; then
          echo "SBOM SARIF file found, validating..."
          # Check if the SARIF file is valid JSON
          if jq . sbom-scan-results.sarif > /dev/null 2>&1; then
            echo "SARIF file is valid JSON"
            # Add basic artifact location if missing
            jq '.runs[].results[]? |= if .locations[]?.physicalLocation.artifactLocation then . else (.locations[]?.physicalLocation.artifactLocation = {"uri": "."}) end' sbom-scan-results.sarif > results.sarif
            echo "SARIF file processed and saved as results.sarif"
          else
            echo "SARIF file is invalid JSON, creating empty SARIF file"
            cat > results.sarif << 'EOF'
        {
          "version": "2.1.0",
          "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
          "runs": [
            {
              "tool": {
                "driver": {
                  "name": "anchore-sbom-scan",
                  "version": "1.0.0"
                }
              },
              "results": []
            }
          ]
        }
        EOF
          fi
        else
          echo "No SBOM SARIF file generated, creating empty SARIF file"
          cat > results.sarif << 'EOF'
        {
          "version": "2.1.0",
          "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
          "runs": [
            {
              "tool": {
                "driver": {
                  "name": "anchore-sbom-scan",
                  "version": "1.0.0"
                }
              },
              "results": []
            }
          ]
        }
        EOF
        fi

    - name: Upload SBOM scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles('results.sarif') != ''
      with:
        sarif_file: results.sarif

  # Security scorecard
  security-scorecard:
    name: OpenSSF Scorecard
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    permissions:
      security-events: write
      id-token: write
      contents: read
      actions: read
    steps:
    - name: Checkout Source
      uses: actions/checkout@v5
      with:
        persist-credentials: false

    - name: Run analysis
      uses: ossf/scorecard-action@v2.4.0
      with:
        results_file: scorecard-results.sarif
        results_format: sarif
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        publish_results: true

    - name: Upload SARIF results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles('scorecard-results.sarif') != ''
      with:
        sarif_file: scorecard-results.sarif

  # Create security issue if problems found
  create-security-issue:
    name: Create Security Issue
    runs-on: ubuntu-latest
    needs: [dependency-audit, container-security-monitoring, secret-monitoring]
    if: always()
    steps:
    - name: Check for security findings
      id: check-findings
      run: |
        echo "Checking for security findings from previous jobs..."

        # Check job results and outputs
        echo "dependency-audit result: ${{ needs.dependency-audit.result }}"
        echo "container-security-monitoring result: ${{ needs.container-security-monitoring.result }}"
        echo "secret-monitoring result: ${{ needs.secret-monitoring.result }}"

        # Set flag if any security issues found
        if [[ "${{ needs.dependency-audit.result }}" == "failure" ||
              "${{ needs.container-security-monitoring.result }}" == "failure" ||
              "${{ needs.secret-monitoring.result }}" == "failure" ]]; then
          echo "SECURITY_ISSUES_FOUND=true" >> $GITHUB_OUTPUT
        else
          echo "SECURITY_ISSUES_FOUND=false" >> $GITHUB_OUTPUT
        fi

    - name: Create security issue
      if: steps.check-findings.outputs.SECURITY_ISSUES_FOUND == 'true'
      uses: actions/github-script@v8
      with:
        script: |
          const title = 'ðŸš¨ Security Alert - Automated Scan Results';
          const labels = ['security', 'automated-scan'];

          let body = '# Security Scan Results\n\n';
          body += 'Automated security monitoring has detected potential issues:\n\n';

          // Check job results
          const dependencyResult = '${{ needs.dependency-audit.result }}';
          const containerResult = '${{ needs.container-security-monitoring.result }}';
          const secretResult = '${{ needs.secret-monitoring.result }}';

          if (dependencyResult === 'failure') {
            body += '- ï¿½ **Dependencies**: Vulnerabilities detected in dependency scan\n';
          }

          if (containerResult === 'failure') {
            body += '- ï¿½ **Containers**: Vulnerabilities found in container security scan\n';
          }

          if (secretResult === 'failure') {
            body += '- ï¿½ **Secrets**: Potential secrets or credentials detected\n';
          }

          body += '\n## Action Required\n';
          body += 'Please review the security scan results and take appropriate action.\n';
          body += 'Check the workflow logs for detailed information.\n\n';
          body += `Scan run: ${context.runId}\n`;
          body += `Workflow: ${context.workflow}\n`;

          // Check if issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'security,automated-scan',
            state: 'open'
          });

          if (existingIssues.data.length === 0) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: labels
            });
          } else {
            // Update existing issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssues.data[0].number,
              body: `## New Scan Results\n\n${body}`
            });
          }
