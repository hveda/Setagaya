name: Continuous Security Monitoring

on:
  schedule:
    # Run every Monday at 2 AM UTC
    - cron: '0 2 * * 1'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of scan to run'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - dependencies
        - containers
        - secrets

permissions:
  contents: read
  security-events: write
  actions: read
  issues: write

env:
  GO_VERSION: '1.25.1'

jobs:
  # Comprehensive dependency audit
  dependency-audit:
    name: Dependency Security Audit
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'dependencies' || github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install nancy (OSS vulnerability scanner)
      run: go install github.com/sonatypecommunity/nancy@latest

    - name: Run nancy scan
      run: |
        cd setagaya
        go list -json -m all | nancy sleuth --loud

    - name: Install govulncheck
      run: go install golang.org/x/vuln/cmd/govulncheck@latest

    - name: Run govulncheck
      run: |
        cd setagaya
        govulncheck -json ./... > vulns.json || true

    - name: Process vulnerability results
      run: |
        if [ -f setagaya/vulns.json ] && [ -s setagaya/vulns.json ]; then
          echo "Vulnerabilities found:"
          cat setagaya/vulns.json | jq '.message' 2>/dev/null || echo "JSON parsing failed"
          
          # Check for vulnerability findings and exit with error if found
          vulnerability_count=$(cat setagaya/vulns.json | jq '[.calls[]?, .requires[]?] | length' 2>/dev/null || echo "0")
          if [ "$vulnerability_count" -gt "0" ]; then
            echo "::error::Found $vulnerability_count vulnerabilities"
            exit 1
          fi
        fi

  # Container security monitoring
  container-security-monitoring:
    name: Container Security Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'containers' || github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build images for scanning
      run: |
        docker build -f setagaya/Dockerfile -t setagaya-monitor:latest . --build-arg GCP_CREDENTIALS_PATH=""
        docker build -f setagaya/Dockerfile.engines.jmeter -t setagaya-jmeter-monitor:latest .

    - name: Scan with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'setagaya-monitor:latest'
        format: 'json'
        output: 'trivy-results.json'

    - name: Check for HIGH/CRITICAL vulnerabilities
      run: |
        if [ -f trivy-results.json ]; then
          high_count=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' 2>/dev/null || echo "0")
          critical_count=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' 2>/dev/null || echo "0")
          
          echo "High severity vulnerabilities: $high_count"
          echo "Critical severity vulnerabilities: $critical_count"
          
          if [ "$critical_count" -gt "0" ] || [ "$high_count" -gt "5" ]; then
            echo "::error::Found $critical_count critical and $high_count high severity vulnerabilities"
            exit 1
          fi
        fi

  # Secret monitoring
  secret-monitoring:
    name: Secret Leak Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'secrets' || github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Run comprehensive secret scan
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: main
        head: HEAD
        extra_args: --only-verified --json
      continue-on-error: true

    - name: Scan for common patterns
      run: |
        # Additional patterns to check
        echo "Scanning for common secret patterns..."
        
        exit_code=0
        
        # Check for potential AWS keys
        if grep -r "AKIA[0-9A-Z]\{16\}" . --exclude-dir=.git; then
          echo "::error::Potential AWS access key found!"
          exit_code=1
        fi
        
        # Check for potential private keys
        if grep -r "BEGIN.*PRIVATE KEY" . --exclude-dir=.git; then
          echo "::error::Potential private key found!"
          exit_code=1
        fi
        
        # Check for hardcoded passwords
        if grep -ri "password.*=" . --include="*.go" --include="*.yaml" --include="*.json" | grep -v "password_hash\|password_file\|_test.go\|example\|template"; then
          echo "::error::Potential hardcoded password found!"
          exit_code=1
        fi
        
        exit $exit_code

  # License compliance monitoring
  license-compliance:
    name: License Compliance Check
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install go-licenses
      run: go install github.com/google/go-licenses@latest

    - name: Check for license issues
      run: |
        cd setagaya
        go-licenses check ./... --disallowed_types=forbidden,restricted \
          --ignore="github.com/hveda/Setagaya" \
          --ignore="github.com/iandyh/eventsource" || true

    - name: Generate license report
      run: |
        cd setagaya
        go-licenses report ./... \
          --ignore="github.com/hveda/Setagaya" \
          --ignore="github.com/iandyh/eventsource" > ../license-report.txt || true
        echo "License report generated"

    - name: Upload license report
      uses: actions/upload-artifact@v4
      with:
        name: license-report
        path: license-report.txt

  # SBOM generation and monitoring
  sbom-monitoring:
    name: SBOM Generation and Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        path: ./
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Scan SBOM for vulnerabilities
      uses: anchore/scan-action@v3
      with:
        sbom: sbom.spdx.json
        output-format: sarif
        output-file: sbom-scan.sarif

    - name: Upload SBOM scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles('sbom-scan.sarif') != ''
      with:
        sarif_file: sbom-scan.sarif
      continue-on-error: true

  # Security scorecard
  security-scorecard:
    name: OpenSSF Scorecard
    runs-on: ubuntu-latest
    if: github.event.inputs.scan_type == 'full' || github.event_name == 'schedule'
    permissions:
      security-events: write
      id-token: write
      contents: read
      actions: read
    steps:
    - name: Checkout Source
      uses: actions/checkout@v4
      with:
        persist-credentials: false

    - name: Run analysis
      uses: ossf/scorecard-action@v2.4.2
      with:
        results_file: results.sarif
        results_format: sarif
        publish_results: true

    - name: Upload SARIF results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles('results.sarif') != ''
      with:
        sarif_file: results.sarif
      continue-on-error: true

  # Create security issue if problems found
  create-security-issue:
    name: Create Security Issue
    runs-on: ubuntu-latest
    needs: [dependency-audit, container-security-monitoring, secret-monitoring]
    if: always()
    steps:
    - name: Check for security findings
      id: check-findings
      run: |
        echo "Checking for security findings from previous jobs..."
        
        # Check job results and outputs
        echo "dependency-audit result: ${{ needs.dependency-audit.result }}"
        echo "container-security-monitoring result: ${{ needs.container-security-monitoring.result }}"
        echo "secret-monitoring result: ${{ needs.secret-monitoring.result }}"
        
        # Set flag if any security issues found
        if [[ "${{ needs.dependency-audit.result }}" == "failure" || 
              "${{ needs.container-security-monitoring.result }}" == "failure" || 
              "${{ needs.secret-monitoring.result }}" == "failure" ]]; then
          echo "SECURITY_ISSUES_FOUND=true" >> $GITHUB_OUTPUT
        else
          echo "SECURITY_ISSUES_FOUND=false" >> $GITHUB_OUTPUT
        fi

    - name: Create security issue
      if: steps.check-findings.outputs.SECURITY_ISSUES_FOUND == 'true'
      uses: actions/github-script@v6
      with:
        script: |
          const title = 'ðŸš¨ Security Alert - Automated Scan Results';
          const labels = ['security', 'automated-scan'];
          
          let body = '# Security Scan Results\n\n';
          body += 'Automated security monitoring has detected potential issues:\n\n';
          
          // Check job results
          const dependencyResult = '${{ needs.dependency-audit.result }}';
          const containerResult = '${{ needs.container-security-monitoring.result }}';
          const secretResult = '${{ needs.secret-monitoring.result }}';
          
          if (dependencyResult === 'failure') {
            body += '- ï¿½ **Dependencies**: Vulnerabilities detected in dependency scan\n';
          }
          
          if (containerResult === 'failure') {
            body += '- ï¿½ **Containers**: Vulnerabilities found in container security scan\n';
          }
          
          if (secretResult === 'failure') {
            body += '- ï¿½ **Secrets**: Potential secrets or credentials detected\n';
          }
          
          body += '\n## Action Required\n';
          body += 'Please review the security scan results and take appropriate action.\n';
          body += 'Check the workflow logs for detailed information.\n\n';
          body += `Scan run: ${context.runId}\n`;
          body += `Workflow: ${context.workflow}\n`;
          
          // Check if issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'security,automated-scan',
            state: 'open'
          });
          
          if (existingIssues.data.length === 0) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: labels
            });
          } else {
            // Update existing issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssues.data[0].number,
              body: `## New Scan Results\n\n${body}`
            });
          }
